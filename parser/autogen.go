package parser

import (
	"fmt"
	"go/ast"
	"path/filepath"
	"regexp"
	"slices"
	"strings"
)

// TypeNode represents a type in the dependency graph
type TypeNode struct {
	Name           string
	PackagePath    string
	IsAnnotated    bool // Has format generator annotation
	ShouldGenerate bool // Should be generated
	Depth          int  // Distance from nearest annotated type
	References     []string
	ReferencedBy   []string
	IsInScope      bool // Whether the type is in parsed packages
}

// DependencyGraph tracks type relationships
type DependencyGraph struct {
	Nodes  map[string]*TypeNode
	Edges  map[string][]string // fromType -> []toTypes
	logger Logger              // Logger for autogen messages
}

// NewDependencyGraph creates a new dependency graph
func NewDependencyGraph(logger Logger) *DependencyGraph {
	if logger == nil {
		logger = NewDefaultLogger()
	}
	return &DependencyGraph{
		Nodes:  make(map[string]*TypeNode),
		Edges:  make(map[string][]string),
		logger: logger,
	}
}

// AddNode adds a type to the graph
func (g *DependencyGraph) AddNode(typeName, packagePath string, isAnnotated, isInScope bool) {
	if _, exists := g.Nodes[typeName]; !exists {
		g.Nodes[typeName] = &TypeNode{
			Name:           typeName,
			PackagePath:    packagePath,
			IsAnnotated:    isAnnotated,
			ShouldGenerate: isAnnotated, // Annotated types always generated by default
			Depth:          -1,
			References:     []string{},
			ReferencedBy:   []string{},
			IsInScope:      isInScope,
		}
	}
}

// AddEdge adds a dependency edge (fromType references toType)
func (g *DependencyGraph) AddEdge(fromType, toType string) {
	if fromType == toType {
		return // Skip self-references
	}

	// Extract package path from qualified type names
	fromTypeName, fromPkgPath := g.extractTypeAndPackage(fromType)
	toTypeName, toPkgPath := g.extractTypeAndPackage(toType)

	// Ensure nodes exist
	if _, exists := g.Nodes[fromTypeName]; !exists {
		g.AddNode(fromTypeName, fromPkgPath, false, false)
	}
	if _, exists := g.Nodes[toTypeName]; !exists {
		g.AddNode(toTypeName, toPkgPath, false, false)
	}

	// Add edge if not already present
	if !slices.Contains(g.Edges[fromTypeName], toTypeName) {
		g.Edges[fromTypeName] = append(g.Edges[fromTypeName], toTypeName)
		g.Nodes[fromTypeName].References = append(g.Nodes[fromTypeName].References, toTypeName)
		g.Nodes[toTypeName].ReferencedBy = append(g.Nodes[toTypeName].ReferencedBy, fromTypeName)
	}
}

// extractTypeAndPackage separates a qualified type name into type and package
func (g *DependencyGraph) extractTypeAndPackage(typeName string) (string, string) {
	if strings.Contains(typeName, ".") {
		parts := strings.Split(typeName, ".")
		if len(parts) == 2 {
			// Qualified name like "time.Duration" -> type="Duration", package="time"
			// Note: This is the package alias, not the full import path
			// For now, we'll use the alias as a best-effort package identifier
			return parts[1], parts[0]
		}
	}
	// Unqualified name
	return typeName, ""
}

// BuildDependencyGraph constructs a dependency graph from parsed structs
func BuildDependencyGraph(structs []*StructInfo, enums []*EnumInfo, config *AutoGenerateConfig, checkAnnotation func(*StructInfo) bool, logger Logger) *DependencyGraph {
	graph := NewDependencyGraph(logger)

	// First pass: Add all types as nodes
	for _, structInfo := range structs {
		isAnnotated := checkAnnotation != nil && checkAnnotation(structInfo)
		graph.AddNode(structInfo.Name, structInfo.PackagePath, isAnnotated, true)
	}

	// Add enums as nodes (they can be annotated or referenced)
	for _, enumInfo := range enums {
		// Enums are considered in-scope since they were parsed
		graph.AddNode(enumInfo.Name, "", false, true)
	}

	// Second pass: Build edges by analyzing struct fields
	for _, structInfo := range structs {
		// Build a set of type parameter names to filter out
		typeParams := make(map[string]bool)

		// For alias instantiations, we need to filter type parameters from the target generic type
		if structInfo.IsAliasInstantiation && structInfo.AliasTarget != "" {
			// Find the target generic struct
			for _, targetStruct := range structs {
				if targetStruct.Name == structInfo.AliasTarget && targetStruct.TypeSpec != nil && targetStruct.TypeSpec.TypeParams != nil {
					for _, param := range targetStruct.TypeSpec.TypeParams.List {
						for _, name := range param.Names {
							typeParams[name.Name] = true
						}
					}
					break
				}
			}
		} else if structInfo.TypeSpec != nil && structInfo.TypeSpec.TypeParams != nil {
			// For regular generic structs, use their own type parameters
			for _, param := range structInfo.TypeSpec.TypeParams.List {
				for _, name := range param.Names {
					typeParams[name.Name] = true
				}
			}
		}

		// Apply include_embedded filter
		for _, field := range structInfo.Fields {
			// Skip embedded fields if configured
			if field.IsEmbedded && config != nil && !config.IncludeEmbedded {
				continue
			}

			// Extract type references from the field
			referencedTypes := extractTypeReferences(field.Type) // For embedded fields, also extract nested references
			if field.IsEmbedded {
				// Add the embedded type itself (filter out type parameters)
				for _, refType := range referencedTypes {
					if refType != "" && refType != structInfo.Name && !typeParams[refType] {
						graph.AddEdge(structInfo.Name, refType)
					}
				}

				// Extract nested references
				nestedRefs := extractNestedReferences(field.Type, structs)
				for _, refType := range nestedRefs {
					if refType != "" && refType != structInfo.Name && !typeParams[refType] {
						graph.AddEdge(structInfo.Name, refType)
					}
				}
			} else {
				// For named fields, add direct references (filter out type parameters)
				for _, refType := range referencedTypes {
					if refType != "" && refType != structInfo.Name && !typeParams[refType] {
						// Apply include_field_types filter
						if config == nil || config.IncludeFieldTypes {
							graph.AddEdge(structInfo.Name, refType)
						}
					}
				}
			}
		}
	}

	return graph
}

// extractNestedReferences extracts type references from fields of an embedded struct
func extractNestedReferences(expr ast.Expr, structs []*StructInfo) []string {
	var types []string

	// Get the embedded type name
	var embeddedTypeName string
	switch t := expr.(type) {
	case *ast.Ident:
		embeddedTypeName = t.Name
	case *ast.StarExpr:
		if ident, ok := t.X.(*ast.Ident); ok {
			embeddedTypeName = ident.Name
		}
	case *ast.IndexExpr:
		// Generic type like Connection[T]
		if ident, ok := t.X.(*ast.Ident); ok {
			embeddedTypeName = ident.Name
		}
	case *ast.SelectorExpr:
		// Package qualified
		embeddedTypeName = t.Sel.Name
	}

	if embeddedTypeName == "" {
		return types
	}

	// Find the embedded struct
	for _, s := range structs {
		if s.Name == embeddedTypeName {
			// Build a set of type parameter names to filter out
			typeParams := make(map[string]bool)
			if s.TypeSpec != nil && s.TypeSpec.TypeParams != nil {
				for _, param := range s.TypeSpec.TypeParams.List {
					for _, name := range param.Names {
						typeParams[name.Name] = true
					}
				}
			}

			// Extract references from all its fields
			for _, field := range s.Fields {
				fieldRefs := extractTypeReferences(field.Type)
				// Filter out type parameters
				for _, ref := range fieldRefs {
					if !typeParams[ref] {
						types = append(types, ref)
					}
				}

				// Recursively handle nested embedded fields
				if field.IsEmbedded {
					nestedRefs := extractNestedReferences(field.Type, structs)
					types = append(types, nestedRefs...)
				}
			}
			break
		}
	}

	return types
}

// extractTypeReferences extracts type names from an AST expression
func extractTypeReferences(expr ast.Expr) []string {
	var types []string

	switch t := expr.(type) {
	case *ast.Ident:
		// Simple type: User, string, int, etc.
		if !IsGoBuiltinType(t.Name) {
			types = append(types, t.Name)
		}

	case *ast.StarExpr:
		// Pointer: *User
		types = append(types, extractTypeReferences(t.X)...)

	case *ast.ArrayType:
		// Slice/Array: []User, []*User
		types = append(types, extractTypeReferences(t.Elt)...)

	case *ast.SelectorExpr:
		// Package-qualified: pkg.User
		if pkgIdent, ok := t.X.(*ast.Ident); ok {
			// Return the full qualified name (pkg.Type) to preserve package information
			qualifiedName := pkgIdent.Name + "." + t.Sel.Name
			types = append(types, qualifiedName)
		}

	case *ast.MapType:
		// Map: map[string]User
		types = append(types, extractTypeReferences(t.Key)...)
		types = append(types, extractTypeReferences(t.Value)...)

	case *ast.IndexExpr:
		// Generic with single type param: Connection[T]
		baseTypes := extractTypeReferences(t.X)
		types = append(types, baseTypes...)
		argTypes := extractTypeReferences(t.Index)
		types = append(types, argTypes...)

	case *ast.IndexListExpr:
		// Generic with multiple type params: Map[K, V]
		baseTypes := extractTypeReferences(t.X)
		types = append(types, baseTypes...)
		for _, index := range t.Indices {
			argTypes := extractTypeReferences(index)
			types = append(types, argTypes...)
		}
	}

	return types
}

// MarkTypesForGeneration traverses the graph and marks types for generation
func (g *DependencyGraph) MarkTypesForGeneration(config *AutoGenerateConfig) error {
	if config == nil || !config.Enabled {
		// Only generate explicitly annotated types
		return nil
	}

	switch config.Strategy {
	case AutoGenNone:
		// Only annotated - already set in AddNode
		return nil

	case AutoGenAll:
		// Generate everything
		for _, node := range g.Nodes {
			if !g.isExcluded(node, config) {
				node.ShouldGenerate = true
			}
		}

	case AutoGenReferenced:
		// BFS from annotated types
		if err := g.markReferencedTypes(config); err != nil {
			return err
		}

	case AutoGenPatterns:
		// Pattern-based only
		g.markByPatterns(config)
	}

	return nil
}

// markReferencedTypes marks types reachable from annotated types
func (g *DependencyGraph) markReferencedTypes(config *AutoGenerateConfig) error {
	// Find all annotated types as starting points
	queue := []string{}
	visited := make(map[string]bool)

	for typeName, node := range g.Nodes {
		if node.IsAnnotated {
			// Apply only_referenced_by_annotated filter
			if config.OnlyReferencedByAnnotated && !node.IsAnnotated {
				continue
			}
			node.Depth = 0
			queue = append(queue, typeName)
			visited[typeName] = true
		}
	}

	// BFS traversal
	for len(queue) > 0 {
		current := queue[0]
		queue = queue[1:]

		currentNode := g.Nodes[current]
		currentDepth := currentNode.Depth

		// Check depth limit
		maxDepth := config.MaxDepth
		if maxDepth > 0 && currentDepth >= maxDepth {
			continue
		}

		// Process references
		for _, refType := range g.Edges[current] {
			refNode, exists := g.Nodes[refType]
			if !exists {
				continue
			}

			// Skip if already visited with lower or equal depth
			if visited[refType] && refNode.Depth <= currentDepth+1 {
				continue
			}

			// Check exclusion patterns
			if g.isExcluded(refNode, config) {
				continue
			}

			// Handle out-of-scope types
			if !refNode.IsInScope {
				if err := g.handleOutOfScopeType(refNode, config); err != nil {
					return err
				}
				if !refNode.ShouldGenerate {
					// Type was excluded by out_of_scope_action policy
					continue
				}
			}

			// Mark for generation
			refNode.ShouldGenerate = true
			refNode.Depth = currentDepth + 1
			visited[refType] = true
			queue = append(queue, refType)
		}
	}

	return nil
}

// isWellKnownType checks if a type is a common stdlib type that is typically handled by plugins
// This is a simple heuristic to avoid warnings for standard library types
func (g *DependencyGraph) isWellKnownType(typeName, packagePath string) bool {
	// Common stdlib packages that plugins typically handle
	commonStdlibPrefixes := []string{
		"time.",
		"encoding/json.",
		"fmt.",
		"io.",
		"net/http.",
		"context.",
	}

	// Check fully qualified name (package.Type)
	fullName := typeName
	if packagePath != "" {
		fullName = packagePath + "." + typeName
	}

	// Check for common stdlib types
	for _, prefix := range commonStdlibPrefixes {
		if strings.HasPrefix(fullName, prefix) {
			return true
		}
	}

	// Check for types that are commonly in the standard library
	commonTypes := []string{"error", "string", "int", "int64", "float64", "bool", "byte", "rune"}
	for _, commonType := range commonTypes {
		if typeName == commonType {
			return true
		}
	}

	return false
} // handleOutOfScopeType handles types that are not in parsed packages
func (g *DependencyGraph) handleOutOfScopeType(node *TypeNode, config *AutoGenerateConfig) error {
	// Skip warnings for known types that have mappings in config
	if g.isWellKnownType(node.Name, node.PackagePath) {
		return nil
	}

	action := OutOfScopeAction(config.OutOfScopeAction)

	switch action {
	case OutOfScopeWarn:
		// Warn but continue
		msg := fmt.Sprintf("Type %s is out of scope (not in parsed packages)", node.Name)
		if node.PackagePath != "" {
			msg += fmt.Sprintf(" (package: %s)", node.PackagePath)
		}
		g.logger.Warn(msg)
		return nil

	case OutOfScopeFail:
		// Fail immediately
		return fmt.Errorf("type %s is out of scope (not in parsed packages)", node.Name)

	case OutOfScopeIgnore:
		g.logger.Debug(fmt.Sprintf("Ignoring out-of-scope type %s", node.Name))
		// Silently continue
		return nil

	case OutOfScopeExclude:
		// Exclude from generation
		g.logger.Debug(fmt.Sprintf("Excluding out-of-scope type %s from generation", node.Name))
		node.ShouldGenerate = false
		return nil

	default:
		return nil
	}
}

// markByPatterns marks types matching inclusion patterns
func (g *DependencyGraph) markByPatterns(config *AutoGenerateConfig) {
	for _, node := range g.Nodes {
		// Annotated types already have their generation flags set
		if node.IsAnnotated {
			continue
		}

		// Check if type matches any inclusion pattern
		if g.matchesPatterns(node, config.Patterns) && !g.matchesPatterns(node, config.ExcludePatterns) {
			node.ShouldGenerate = true
		}
	}
}

// isExcluded checks if a type should be excluded
func (g *DependencyGraph) isExcluded(node *TypeNode, config *AutoGenerateConfig) bool {
	if len(config.ExcludePatterns) == 0 {
		return false
	}
	return g.matchesPatterns(node, config.ExcludePatterns)
}

// matchesPatterns checks if a type matches any of the given patterns
func (g *DependencyGraph) matchesPatterns(node *TypeNode, patterns []string) bool {
	for _, pattern := range patterns {
		// Support glob patterns and regex
		if strings.HasPrefix(pattern, "/") && strings.HasSuffix(pattern, "/") {
			// Treat as regex
			regexPattern := strings.Trim(pattern, "/")
			if matched, _ := regexp.MatchString(regexPattern, node.Name); matched {
				return true
			}
		} else {
			// Treat as glob pattern
			if matched, _ := filepath.Match(pattern, node.Name); matched {
				return true
			}

			// Try matching against package path + type name
			fullPath := filepath.Join(node.PackagePath, node.Name)
			if matched, _ := filepath.Match(pattern, fullPath); matched {
				return true
			}
		}
	}
	return false
}

// ApplyAutoGeneration filters structs based on auto-generation configuration
func ApplyAutoGeneration(structs []*StructInfo, enums []*EnumInfo, config *AutoGenerateConfig, checkAnnotation func(*StructInfo) bool, logger Logger) ([]*StructInfo, error) {
	// Debug: check if alias is in input
	// for _, s := range structs {
	// 	if s.IsAliasInstantiation {
	// fmt.Printf("[DEBUG AUTOGEN INPUT] Alias %s with %d annotations\n", s.Name, len(s.Annotations))
	// 		hasAccepted := checkAnnotation(s)
	// fmt.Printf("[DEBUG AUTOGEN INPUT]   checkAnnotation returned: %v\n", hasAccepted)
	// 	}
	// }

	if config == nil || !config.Enabled {
		// Only return annotated structs
		filtered := make([]*StructInfo, 0)
		for _, s := range structs {
			if checkAnnotation(s) {
				filtered = append(filtered, s)
			}
		}
		return filtered, nil
	}

	// Build dependency graph
	graph := BuildDependencyGraph(structs, enums, config, checkAnnotation, logger)

	// Mark types for generation based on strategy
	if err := graph.MarkTypesForGeneration(config); err != nil {
		return nil, err
	}

	// Filter structs based on what should be generated
	filtered := make([]*StructInfo, 0)
	for _, s := range structs {
		// ALWAYS include annotated structs, even if not in dependency graph or not marked for generation
		if checkAnnotation != nil && checkAnnotation(s) {
			//fmt.Printf("[DEBUG AUTOGEN FILTER] Including annotated struct: %s\n", s.Name)

			filtered = append(filtered, s)
			continue
		}

		// Include non-annotated structs only if marked for generation by the dependency graph
		if node, exists := graph.Nodes[s.Name]; exists {
			if node.ShouldGenerate {
				// fmt.Printf("[DEBUG AUTOGEN FILTER] Including non-annotated struct from graph: %s\n", s.Name)
				filtered = append(filtered, s)
			}
		}
		// Note: Alias instantiations not in dependency graph are skipped
		// fmt.Printf("[DEBUG AUTOGEN] Alias %s NOT in dependency graph!\n", s.Name)
	}

	// fmt.Printf("[DEBUG AUTOGEN FILTER] Total filtered: %d\n", len(filtered))
	return filtered, nil
}
